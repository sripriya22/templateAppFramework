#!/usr/bin/env node
// utils/generate-classes.js
import { writeFile, mkdir, readdir, readFile, access } from 'fs/promises';
import { dirname, join, basename, resolve, relative } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

/**
 * Ensures the specified directory exists
 * @param {string} dirPath - Path to the directory
 */
async function ensureDirectoryExists(dirPath) {
    try {
        await mkdir(dirPath, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') throw err;
    }
}

/**
 * Reads all JSON model files from a directory
 * @param {string} sourceDir - Directory containing JSON model files
 * @returns {Promise<Object>} Object with class names as keys and their definitions as values
 */
async function readModelDefinitions(sourceDir) {
    const files = await readdir(sourceDir);
    const jsonFiles = files.filter(file => file.endsWith('.json'));
    const definitions = {};
    
    for (const file of jsonFiles) {
        try {
            const content = await readFile(join(sourceDir, file), 'utf8');
            const def = JSON.parse(content);
            const className = def.ClassName || basename(file, '.json');
            definitions[className] = def;
        } catch (err) {
            console.error(`Error reading model file ${file}:`, err);
        }
    }
    
    return definitions;
}

/**
 * Analyzes dependencies between model definitions
 * @param {Object} definitions - Object containing model definitions
 * @returns {Array<string>} Sorted array of class names in dependency order
 */
function sortDefinitionsByDependencies(definitions) {
    const graph = {};
    const visited = {};
    const result = [];
    
    // Build dependency graph
    Object.keys(definitions).forEach(className => {
        const deps = [];
        const def = definitions[className];
        
        // Find all class references in properties
        if (def.Properties) {
            Object.values(def.Properties).forEach(prop => {
                if (prop.Type && definitions[prop.Type] && !deps.includes(prop.Type)) {
                    deps.push(prop.Type);
                }
            });
        }
        
        graph[className] = deps;
    });
    
    // Topological sort
    function visit(className) {
        if (visited[className] === 2) return; // Already visited
        if (visited[className] === 1) {
            throw new Error(`Circular dependency detected involving ${className}`);
        }
        
        visited[className] = 1; // Mark as visiting
        
        // Visit all dependencies first
        graph[className].forEach(dep => {
            if (definitions[dep]) {
                visit(dep);
            }
        });
        
        visited[className] = 2; // Mark as visited
        result.push(className);
    }
    
    // Visit all nodes
    Object.keys(definitions).forEach(className => {
        if (!visited[className]) {
            visit(className);
        }
    });
    
    return result;
}

/**
 * Generates JavaScript class code from a model definition
 * @param {string} className - Name of the class to generate
 * @param {string} baseClassName - Name of the base class to extend
 * @returns {string} Generated JavaScript class code
 */
function generateClassFile(className, baseClassName) {
    const importPath = baseClassName === 'AbstractModelObject' 
        ? '../../appFramework/model/AbstractModelObject.js'  // Absolute path from web root
        : `./${baseClassName}.js`;
    
    return `// Auto-generated model class
// DO NOT EDIT THIS FILE DIRECTLY

import { ${baseClassName} } from '${importPath}';

/**
 * ${className} model class
 * @extends ${baseClassName}
 */
export class ${className} extends ${baseClassName} {
    /** @type {string} */
    static className = '${className}';
    
    /**
     * Get the model name (used for registration)
     * @returns {string} The model name
     */
    static get modelName() {
        return this.className;
    }
    
    /**
     * Get the parent model name
     * @returns {string} The parent model name
     */
    static get parentModelName() {
        return '${baseClassName}';
    }
    
    // Add any custom methods below this line
    // They will be preserved between generations
}`;
}

/**
 * Generates class files from model definitions
 * @param {Object} definitions - Object containing model definitions
 * @param {string} outputDir - Directory to write generated class files to
 * @returns {Promise<Object>} Map of class names to their constructors
 */
async function generateAllClasses(definitions, outputDir) {
    await ensureDirectoryExists(outputDir);
    const sortedClasses = sortDefinitionsByDependencies(definitions);
    const classMap = {};
    
    // Generate class files in dependency order
    for (const className of sortedClasses) {
        const definition = definitions[className];
        const baseClassName = definition.Extends || 'AbstractModelObject';
        
        const classCode = generateClassFile(className, baseClassName);
        const outputFile = join(outputDir, `${className}.js`);
        await writeFile(outputFile, classCode, 'utf8');
        
        console.log(`Generated: ${outputFile}`);
    }
    
    // Generate index.js with all exports
    const indexContent = `// Auto-generated index file
// DO NOT EDIT THIS FILE DIRECTLY

${sortedClasses.map(className => `import { ${className} } from './${className}.js';`).join('\n')}

export {
    ${sortedClasses.join(',\n    ')}
};
`;
    
    await writeFile(join(outputDir, 'index.js'), indexContent, 'utf8');
    console.log(`Generated: ${join(outputDir, 'index.js')}`);
    
    // Just use the class names directly
    // The actual classes will be available when imported by the application
    for (const className of sortedClasses) {
        classMap[className] = className;
    }
    
    return classMap;
}

/**
 * Generates class files from all JSON model files in a directory
 * @param {string} sourceDir - Directory containing JSON model files
 * @param {string} outputDir - Directory to write generated class files to
 * @returns {Promise<Object>} Map of class names to their constructors
 */
async function generateClassesFromDirectory(sourceDir, outputDir) {
    const definitions = await readModelDefinitions(sourceDir);
    return generateAllClasses(definitions, outputDir);
}

// Command-line interface
if (process.argv[1] === fileURLToPath(import.meta.url)) {
    const args = process.argv.slice(2);
    
    // Get the relative app directory from command line
    const appDirArg = args.length > 0 ? args[0] : '.';
    
    // Resolve paths relative to current working directory
    const appDir = resolve(process.cwd(), appDirArg);
    const outputDir = resolve(appDir, 'model');
    const sourceDir = resolve(appDir, 'data-model');
    console.log("appDir:", appDir);
    console.log("outputDir:", outputDir);
    console.log("sourceDir:", sourceDir);
    
    // For dynamic imports, we need to use a file:// URL
    const importPath = `file://${outputDir}/index.js`;
    
    console.log(`Using application directory: ${appDir}`);
    console.log(`Using source directory: ${sourceDir}`);
    console.log(`Output will be written to: ${outputDir}`);
    console.log(`Using import path: ${importPath}`);
    
    // Check if source directory exists
    try {
        await access(sourceDir);
    } catch (err) {
        console.error(`Error: Source directory not found: ${sourceDir}`);
        console.error('Make sure your app has a data-model directory with JSON model definitions.');
        process.exit(1);
    }
    
    console.log(`Generating model classes from ${sourceDir} to ${outputDir}`);
    
    try {
        const classes = await generateClassesFromDirectory(sourceDir, outputDir);
        console.log(`âœ… Successfully generated ${Object.keys(classes).length} model classes`);
        console.log('Generated classes:');
        Object.keys(classes).forEach(className => {
            console.log(`  - ${className}`);
        });
    } catch (err) {
        console.error('Error generating model classes:', err);
        process.exit(1);
    }
}

export {
    generateClassesFromDirectory,
    generateAllClasses,
    generateClassFile,
    readModelDefinitions,
    sortDefinitionsByDependencies
};
